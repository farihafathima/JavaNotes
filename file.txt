
bacthstatements
resultset manipulation
callable
preapedstatement
save and retieve an image
-bytestream
-inputstream
-blob
drl commands
auto commit
rollback
savepoint
jdbc concepts
----
collections and map
arrays 
wrapper classes
unboxing
auto boxing
==
var args
static import
java.uitl ARRays class-methods
iterable-collection and its types
porgrams in java
-----
typesafe-mention the datatype during declaration and typeunsafe no datatype mention
add,remove,clear,size,isempty of list collection
iterable-collections-
indexed collection,order is preserved-1.list-arraylist,linkedlist,vector-stack 
order is not preserved ,not indexed--2.set-hashset,sortedset:treeset-bst
map-hashmap no order preser,sortedmap  
methods to iterate collections
list(4)--foreach loop
foreach method
iterator
listiterator
vector(5)+enumaration
set(3)-foreach loop
foreach method
iterator
map iterates through only using foreach method*
--multivalued map explore
hashtable a class and its programs
hashtable is a legacy class for maps
vector is a legacy class for collections.
---------
comparator,comparable;
--
comparator-sort multiple logics
comparable-sort on single logic
--generics-for typesafety they are introduced.


Act$CgG@$2022-ACT

cursors
triggers
sub queries
indexes
views
stored procedures
functions

------------------------------------------------hibernate-creating maven project------------------------orm-object relational mapping
creating a maven project
new-maven project-next
catalog=internal
filter=quickstart
select maven-archtype-quickstart
groupid=package name=cggintens.hibernate
atifact id=project name=hibernateproject
package=cgginterns.hibernate(Same as grupid)
gupid-pakg name
artfctid-projct name
-----------------
adding hibernate dependencies using maven=//maven will download put the jars in the class path
search for hibernate maven to pom.xml-project object model(pom)

update maven project=to download dependecies
right click on project =select maven-select update-force update-only once enough //all the pkg will get installed

for jdk-1.5
to update java vesion from 1.5 to 20
update java version
right click on proj
build path

--------------
configure hibernate
via xml:
rightclick src/main/java->new->other->select xml file->hibernate.cfg.xml->finish//parallel to pkg

	<?xml version="1.0" encoding="UTF-8"?>
hibernate dtd search from google--index dtd

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-configuration PUBLIC
	"-//Hibernate/Hibernate Configuration DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
	
	<hibernate-configuration>
	
	<session-factory>
	
	<property name="conncection.driver_class">
	org.postgresql.Driver
	</property>
	
	<property name="connection.url">
	jdbc:postgresql://localhost:5432/myhiber
	</property>
	
	<property name="connection.username">
	postgres
	</property>
	
	<property name="connection.password">
	1234
	</property>
	
	<property name="dialect">---------//for any changes in commands
	org.hibernate.dialect.PostgreSQLDialect
	</property>
	
	<property name="hbm2ddl.auto">-----------//hibernate to ddl commands --update indicates to create that table if not exists
	update				
	</property>
	
	<property name="show_sql">-------//see the queries generated by hibernate
	true
	</property>
	<mapping class="cgginterns.hibernate.Student"/>-----//map the entity where it has to be created
	</session-factory>
	
	</hibernate-configuration>

----------------------------------------------------------------------------------
after configuring hb
create a database called "myhiber"
using pgadmin
-------------
create a student object 
we need an interface to use
 -->>SessionFactory factory = new Configuration().configure().buildSessionFactory();
in 3 commands
--------------then start a session and transaction and save the changes to the database and commit
Session session=factory.openSession();
        Transaction tx= session.beginTransaction();
        session.save(student);
        tx.commit();
     session.close();
    factory.close();
-----------------------end-----------------
---------------------------------------------
30.05.2023
----------------start-----------
"commonly used hibernate annotations"
@Entity-used to mark any class as entity
@Id-used to mark a column as primary key
@Table-used to change table details

stroing and fetching image

"""fetch data"""
-get and load methods
GET -FULLY INITIALISED OBJECTS
LOAD -PROXY will be created (lazy initialization)
@Embeddable-EMDemo
-->fields of a new table(class) are added as columns to existing table(class).
mappings--4 types :to join tables
-one to one: col is  created
-one to many:col,table is created can ignore the other by using mappedBy
-many to one:col,table is created
-many to many:table,table is created-join com,inverse join col
-------------------
one to one--
----------
one to many question has many answers
-------------------------------------------------------------
5/6/23
-------:::::::::::::::FETCH TYPES-1.lazy,2.eager
lazy-call size or getters to load answers only quesition is loaded-till you do some action it will not load
eager-loading a quesiotn will also load associated answers--on the spot
lazy:in lazy loading associated data loads only when we explicityly call getter or size method
eager:it is a design pattern in which data loading occurs on the spot
brand product example --select command
------------------------------------------------------
OBJECT STATES::::::::::::hibernate/persistance lifecycle states
::obj-------------------------database:in order to reach database ,java object goes through  various lifecycle states:4 states
1.transient
2.persistent
3.detached
4.removed
session obj with hibernate
java obj
database
----------
create and initalise-transient
transient state: when we make an object and set its properties.
it is(object)  not associated with db or session.

transient--persisten:save method/persist method
persistent:object is stored in table row
any modifications will be reflected in db
as soon as you call save it enters into persistent state.
obj is associate with session and db

persistent--detach;::close or clear session obj is in db ,but not in session
detached :detached from session but attached to db
when session is closed or cleared obj enters detach state.

from detach to persistent-update method
gets associated to session and enter persistent state with update method

removed state:not in db,but in session
delete method is called :persistent to removed state
obj is in session but removed from db
--------------------------------------------------------------------------------
to operate on complex data--fetch complex data
		"""""""""""HQL-hibernate query  language""""""""""""""""""
--db independent
its destination is class not tables
targets classes and its fields
inorder to work on complex data we use hql
where with multiple condition
joining tables
updating multiple columns

hibernate supports both hql and sql
if you are sure db will not be changed the prefer sql
or else hql is preferred by programmer

String query="from Student as st where st.city= :x and st.name= :n";
//alias for table in hql::String query="from Student  st where st.city= :x and st.name= :n";
	Query q = s.createQuery(query);
	q.setParameter("x", "hyd");
	q.setParameter("n", "hto");
reslut set traversing using list traversal
List <Student>list = q.list();
for (Student student : list) {
	System.out.println(student.getName()+" "+student.getCerti().getCourse());
}


git push into repository
-create a pipeline
cmd:git remote add origin <link>http://github.com/captain2376/HibernateProject.git
now push into repo
cmd:git push origin master

-----------------------------------------------------------------------------------------------------------------
7/6/23
-------------------------------------------------------------------------------------------------------------
//HQL
delete 
		Transaction tx = s.beginTransaction();
		
		//delete query
		
		Query q1=s.createQuery("delete from Student st where st.city= :x");
		
		q1.setParameter("x", "hyd");
		int r=q1.executeUpdate();
		System.out.println("deleted :");
		System.out.println(r);
		
		tx.commit();
		
//update query
		
		Transaction tx = s.beginTransaction();
		//create query from session
		Query q1=s.createQuery("update Student set City= :c where name= :n");
		
		q1.setParameter("c", "delhi");//set the parameters
		q1.setParameter("n", "raj");//set the parameters
		int r = q1.executeUpdate();
		System.out.println("updated :"+ r);
		
		tx.commit();
--
//how to execute join query
		
		Query q1 = s.createQuery("select b.brandId,b.brandName,p.productName from Brand as b INNER JOIN b.products as p");
		
		List <Object []>list2 = q1.getResultList();
		
		//array of arraylist every elements of the list is object array
		
		for (Object[] arr : list2) {
			System.out.println(Arrays.toString(arr));
		}
//pagination
		Session session = factory.openSession();
		
		Query q = session.createQuery("from Student");
		
		//implementing pagination using hibernate
		
		//starting index and page size are required
		
		q.setFirstResult(0);//starting index
		q.setMaxResults(5);//page size
		
		List <Student>list = q.list();
		
		for (Student student : list) {
			System.out.println(student.getId()+" : "+ student.getName()+" : "+student.getCity());
		}
		
		session.close();

//sql example
SessionFactory factory = new Configuration().configure().buildSessionFactory();
		
		Session session = factory.openSession();
		
		
		//sql query
		String query="select * from student";
		
		NativeQuery nq = session.createNativeQuery(query);
		
		List<Object []> list = nq.list();
		
		for (Object[] object : list) {
			//System.out.println(Arrays.toString(object));
			//using index
			System.out.println(object[0]+" : "+object[4]);
		}
		
		
		session.close();
		
		factory.close();
//sql example and pagination
Session session = factory.openSession();
		
		
		//sql query
		String query="select * from student";
		
		NativeQuery nq = session.createNativeQuery(query);
		
		nq.setFirstResult(0);//starting index
		nq.setMaxResults(5);//page size
		List<Object []> list = nq.list();
		
		for (Object[] object : list) {
			//System.out.println(Arrays.toString(object));
			System.out.println(object[0]+" : "+object[4]);
		}
		
		
		session.close();
//cascade example
	Session session = factory.openSession();
		
		Brand b1=new Brand();
		b1.setBrandId(4);
		b1.setBrandName("SAMSUNG");
		
		Product p1 = new Product(41,"SamsungPhone");
		
		Product p2 = new Product(42,"Samsung pods");
		
		Product p3 = new Product(43,"Samsung TV");
		
		ArrayList<Product> list = new ArrayList<Product>();
		list.add(p2);
		list.add(p3);
		list.add(p1);
		
		b1.setProducts(list);
		
		Transaction t = session.beginTransaction();
		session.save(b1);
		
		//in brand class changes made cascade all is added
//		@OneToMany(mappedBy="brand",fetch=FetchType.LAZY,cascade=CascadeType.ALL)
//		//if join is not there productbrand table is not created
//		List<Product> products;
		
		
		t.commit();
---------------------------------
-----CACHE----
 HIBERNANTE CACHING
-reduce no. db queries
-enhance the performance of application
1.first level-session obj,there -by default
2.second level-sesion factory ,there -manually
3.query level-but not frequently used

practicals::
first level example
SessionFactory factory = new Configuration().configure().buildSessionFactory();
		Session session = factory.openSession();
		//as long as you dont close the session it will be there in cache memory
		
		Student student = session.get(Student.class, 21);
		System.out.println(student);
		
		System.out.println("working something.......");
		
		//need the same object once again
		//so ask session
		
		Student student2 = session.get(Student.class, 21);
		
		System.out.println(student2);
		
		//session method to know objec exists in session.contains()
		System.out.println(session.contains(student));
		
		session.close();
factory.close();
---------------------------------------------------------------------------------------
6/8/23
---------------------------------------------------------------------------------------
Hibernate second level cache
xml mapping
criteria api
------------
second level cache
we need to install dependencies

1. type net.sf.ehcache maven
copy the dependency in pom.xml
<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-ehcache</artifactId>
			<version>5.6.15.Final</version>
		</dependency>
		
2.type hibernate cache maven
hibernate cache maven and hibernate version should match.
hibernate version
    <!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core -->
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>5.6.15.Final</version>
		</dependency>
--then copy the dependecies in pom.xml

3.set few properties in hibernate configuration file-hibernate.cfg.xml
	<property name="cache.use_second_level_cache">
	true
	</property>
	----
	<property name="cache.region.factory_class">
	org.hibernate.cache.ehcache.internal.EhcacheRegionFactory
	</property>
	
4.write @Cacheble and @Cache annotation on the entity class for which 
second level caching is to be enabled.
@Cacheable
@Cache(usage=CacheConcurrencyStrategy.READ_ONLY

5.write an application to test second level caching
SessionFactory factory = new Configuration().configure().buildSessionFactory();
		Session session = factory.openSession();
		
		//Student s1 = session.get(Student.class, 11);
		Brand b1 = session.get(Brand.class, 8);
		System.out.println(b1);
		//System.out.println(s1);
		
		session.close();
		
		Session session2 = factory.openSession();
		//Student s2 = session2.get(Student.class, 11);
		//System.out.println(s2);		
		Brand b2 = session2.get(Brand.class, 8);
		System.out.println(b2);
		
		session2.close();
		
		factory.close();
		
-----------------------------
XML MAPPING
no need to give annotations in class 

Student.hbm.xml file should be created

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC 
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
  
  <hibernate-mapping>
   <class name="cgg.hibernate.xmlmapping.Person" table="Person">
   
   	<id name="id" column="person_id">
   	<generator class="native"></generator>
   	
   	</id>
   	
   	<property name="name" column="person_name" type="string"/>
   	<property name="phone" column="person_phone " type="string"/>
   	<property name="address" column="person_address" type="string"/>
   </class>
  
  </hibernate-mapping>
 
 -----
 Person class is already created
 <mapping resource="cgg/hibernate/xmlmapping/Person.hbm.xml"/>
 add this to cfg.xml file
-----------------------------------------
9/6/23
----------------------------------------
criteria api-?-they reduce the burden of writing queries
code-----
----------Criteria c  = session.createCriteria(Student.class);
			//c.add(Restrictions.eq("certi.course", "Core Java"));
			c.add(Restrictions.like("certi.course", "R%"));
			c.add(Restrictions.gt("id", 10));
			
			List<Student> list=c.list();
			 for(Student s:list)
			 {
				 System.out.println(s);
			 }
			 
----------------------------
java 8 se features
DATE AND TIME
INSTANT CLASS- is useful for generating timestamp to represent machine time.
Instant current time=Instant.now();
------------------
LOCALDATECLASS
-no time and zone
represents date without time and zone
useful to represent date related things like bday
important methods
-now:static method to return todays date
-of:cretes local date
-getXXX()-used to return parts of date
plusXXX()-adds a specific part
minusXXX()-subtracts
isXXX()-performs check
withXXX()-returns a copy of local date with the factor set to given value
year-month-day :format :2023-06-09
--------------------------------
LocalDate today = LocalDate.now();
		System.out.println("todays date: "+today);
		//convert number into date
		LocalDate setDate = LocalDate.of(2014, 6, 2);
		LocalDate ofDate = LocalDate.of(2001, Month.JUNE, 1);
		System.out.println("Bday : "+ofDate);
		System.out.println("formation day : "+setDate);
		//plus date
		System.out.println("tomorrow's date: "+today.plusDays(1));
		//minus date
		System.out.println("last month :"+today.minusMonths(1));
		//is method
		System.out.println("is leap year : "+today.isLeapYear());
		//with method
		System.out.println("Move to the 30th day of the month : "+today.withDayOfMonth(30));
		System.out.println("Move to the  day of the year : "+today.withDayOfYear(160));
--------------------------------------
similar methods exist in localtime and localdatetime
except plushours() and plus minutes()
-----------ZonedDateTime--------
		ZonedDateTime parisTime = ZonedDateTime.now(ZoneId.of("Europe/Paris"));
----------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////



















